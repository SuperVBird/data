{"id":176133,"link":"https://chinadigitaltimes.net/chinese/2011/08/阮一峰-jquery的deferred对象详解/","date":"2011-09-01T00:23:21Z","modified":"2011-09-01T00:23:21Z","title":"阮一峰 | jQuery的deferred对象详解","content":"<p><p><a rel=\"nofollow\" href=\"http://jquery.com/\">jQuery</a>的开发速度很快，几乎每半年一个大版本，每两个月一个小版本。</p>\n<p>每个版本都会引入一些新功能。今天我想介绍的，就是从jQuery 1.5.0版本开始引入的一个新功能&#8212;-<a rel=\"nofollow\" href=\"http://api.jquery.com/category/deferred-object/\">deferred对象</a>。</p>\n<p>这个功能很重要，未来将成为jQuery的核心方法，它彻底改变了如何在jQuery中使用ajax。为了实现它，jQuery的全部ajax代码都被改写了。</p>\n<p>但是，它比较抽象，初学者很难掌握，网上的教程也不多。所以，我把自己的学习笔记整理出来了，希望对大家有用。</p>\n<p>本文不是初级教程，针对的读者是那些已经具备jQuery使用经验的开发者。如果你想了解jQuery的基本用法，请阅读我编写的<a rel=\"nofollow\" href=\"http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html\">《jQuery设计思想》</a>和<a rel=\"nofollow\" href=\"http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html\">《jQuery最佳实践》</a>。</p>\n<p>======================================</p>\n<p><strong>jQuery的deferred对象详解</strong></p>\n<p>作者：阮一峰</p>\n<p><img src=\"http://image.beekka.com/blog/201108/bg2011081601.jpg\" /></p>\n<p><strong>一、什么是deferred对象？</strong></p>\n<p>开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。</p>\n<p>通常的解决方法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。</p>\n<p>但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了<a rel=\"nofollow\" href=\"http://api.jquery.com/category/deferred-object/\">deferred对象</a>。</p>\n<p><strong>简单说，deferred对象就是jQuery的回调函数解决方案。</strong>在英语中，defer的意思是&#8221;延迟&#8221;，所以deferred对象的含义就是&#8221;延迟&#8221;到未来某个点再执行。</p>\n<p>它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口。它的主要功能，可以归结为四点。下面我们通过示例代码，一步步来学习。</p>\n<p><strong>二、ajax操作的链式写法</strong></p>\n<p>jQuery的ajax操作，传统写法是这样的：</p>\n<blockquote>\n<p>　　$.ajax(</p>\n<p>　　　　url: &#8220;test.html&#8221;,</p>\n<p>　　　　success: function()<br />\n　　　　　　alert(&#8220;哈哈，成功了！&#8221;);<br />\n　　　　,</p>\n<p>　　　　error:function()<br />\n　　　　　　alert(&#8220;出错啦！&#8221;);<br />\n　　　　</p>\n<p>　　});</p>\n<p>（运行<a rel=\"nofollow\" href=\"http://jsfiddle.net/ruanyf/pdQYH/\">代码示例1</a>）</p>\n</blockquote>\n<p>在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。</p>\n<p>$.ajax()操作完成后，如果使用的是低于1.5.0版本的jQuery，返回的是XHR对象，你没法进行链式操作；如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。</p>\n<p>现在，新的写法是这样的：</p>\n<blockquote>\n<p>　　$.ajax(&#8220;test.html&#8221;)</p>\n<p>　　<strong>.done(function() alert(&#8220;哈哈，成功了！&#8221;); )</strong></p>\n<p>　　<strong>.fail(function() alert(&#8220;出错啦！&#8221;); );</strong></p>\n<p>（运行<a rel=\"nofollow\" href=\"http://jsfiddle.net/ruanyf/dYKLJ/\">代码示例2</a>）</p>\n</blockquote>\n<p>可以看到，<a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.done/\">done()</a>相当于success方法，<a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.fail/\">fail()</a>相当于error方法。采用链式写法以后，代码的可读性大大提高。</p>\n<p><strong>三、指定同一操作的多个回调函数</strong></p>\n<p>deferred对象的一大好处，就是它允许你自由添加多个回调函数。</p>\n<p>还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，我还想再运行一个回调函数，怎么办？</p>\n<p>很简单，直接把它加在后面就行了。</p>\n<blockquote>\n<p>　　$.ajax(&#8220;test.html&#8221;)</p>\n<p>　　.done(function() alert(&#8220;哈哈，成功了！&#8221;); )</p>\n<p>　　.fail(function() alert(&#8220;出错啦！&#8221;);  )</p>\n<p>　　<strong>.done(function() alert(&#8220;第二个回调函数！&#8221;); );</strong></p>\n<p>（运行<a rel=\"nofollow\" href=\"http://jsfiddle.net/ruanyf/sQYjs/\">代码示例3</a>）</p>\n</blockquote>\n<p>回调函数可以添加任意多个，它们按照添加顺序执行。</p>\n<p><strong>四、为多个操作指定回调函数</strong></p>\n<p>deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。</p>\n<p>请看下面的代码，它用到了一个新的方法<a rel=\"nofollow\" href=\"http://api.jquery.com/jQuery.when/\">$.when()</a>：</p>\n<blockquote>\n<p>　　<strong>$.when($.ajax(&#8220;test1.html&#8221;), $.ajax(&#8220;test2.html&#8221;))</strong></p>\n<p>　　.done(function() alert(&#8220;哈哈，成功了！&#8221;); )</p>\n<p>　　.fail(function() alert(&#8220;出错啦！&#8221;); );</p>\n<p>（运行<a rel=\"nofollow\" href=\"http://jsfiddle.net/ruanyf/CdKjn/\">代码示例4</a>）</p>\n</blockquote>\n<p>这段代码的意思是，先执行两个操作$.ajax(&#8220;test1.html&#8221;)和$.ajax(&#8220;test2.html&#8221;)，如果成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。</p>\n<p><strong>五、普通操作的回调函数接口（上）</strong></p>\n<p>deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作&#8212;-不管是ajax操作还是本地操作，也不管是异步操作还是同步操作&#8212;-都可以使用deferred对象的各种方法，指定回调函数。</p>\n<p>我们来看一个具体的例子。假定有一个很耗时的操作wait：</p>\n<blockquote>\n<p>　　var wait = function()</p>\n<p>　　　　var tasks = function()</p>\n<p>　　　　　　alert(&#8220;执行完毕！&#8221;);</p>\n<p>　　　　;</p>\n<p>　　　　setTimeout(tasks,5000);</p>\n<p>　　};</p>\n</blockquote>\n<p>我们为它指定回调函数，应该怎么做呢？</p>\n<p>很自然的，你会想到，可以使用$.when()：</p>\n<blockquote>\n<p>　　$.when(wait())</p>\n<p>　　.done(function() alert(&#8220;哈哈，成功了！&#8221;); )</p>\n<p>　　.fail(function() alert(&#8220;出错啦！&#8221;); );</p>\n</blockquote>\n<p>但是，有一个问题。$.when()的参数只能是deferred对象，所以必须对wait进行改写：</p>\n<blockquote>\n<p>　　var dtd = $.Deferred(); // 新建一个deferred对象</p>\n<p>　　var wait = function(dtd)</p>\n<p>　　　　var tasks = function()</p>\n<p>　　　　　　alert(&#8220;执行完毕！&#8221;);</p>\n<p>　　　　　　<strong>dtd.resolve();</strong> // 改变deferred对象的执行状态</p>\n<p>　　　　;</p>\n<p>　　　　setTimeout(tasks,5000);</p>\n<p>　　　　<strong>return dtd.promise();</strong></p>\n<p>　　};</p>\n</blockquote>\n<p>这里有两个地方需要注意。</p>\n<p>首先，最后一行不能直接返回dtd，必须返回<a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.promise/\">dtd.promise()</a>。原因是jQuery规定，任意一个deferred对象有三种执行状态&#8212;-未完成，已完成和已失败。如果直接返回dtd，$.when()的默认执行状态为&#8221;已完成&#8221;，立即触发后面的done()方法，这就失去回调函数的作用了。dtd.promise()的目的，就是保证目前的执行状态&#8212;-也就是&#8221;未完成&#8221;&#8212;-不变，从而确保只有操作完成后，才会触发回调函数。</p>\n<p>其次，当操作完成后，必须手动改变Deferred对象的执行状态，否则回调函数无法触发。<a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.resolve/\">dtd.resolve()</a>的作用，就是将dtd的执行状态从&#8221;未完成&#8221;变成&#8221;已完成&#8221;，从而触发done()方法。</p>\n<p>最后别忘了，修改完wait之后，调用的时候就必须直接传入dtd参数。</p>\n<blockquote>\n<p>　　$.when(wait(dtd))</p>\n<p>　　.done(function() alert(&#8220;哈哈，成功了！&#8221;); )</p>\n<p>　　.fail(function() alert(&#8220;出错啦！&#8221;); );</p>\n<p>（运行<a rel=\"nofollow\" href=\"http://jsfiddle.net/ruanyf/zSddB/1/\">代码示例5</a>）</p>\n</blockquote>\n<p><strong>六、普通操作的回调函数接口（中）</strong></p>\n<p>除了使用$.when()为普通操作添加回调函数，还可以使用deferred对象的建构函数$.Deferred()。</p>\n<p>这时，wait函数还是保持不变，我们直接把它传入$.Deferred()：</p>\n<blockquote>\n<p>　　<strong>$.Deferred(wait)</strong></p>\n<p>　　.done(function() alert(&#8220;哈哈，成功了！&#8221;); )</p>\n<p>　　.fail(function() alert(&#8220;出错啦！&#8221;); );</p>\n<p>（运行<a rel=\"nofollow\" href=\"http://jsfiddle.net/ruanyf/CucGp/\">代码示例6</a>）</p>\n</blockquote>\n<p>jQuery规定，$.Deferred()可以接受一个函数作为参数，该函数将在$.Deferred()返回结果之前执行。并且，$.Deferred()所生成的Deferred对象将作为这个函数的默认参数。</p>\n<p><strong>七、普通操作的回调函数接口（下）</strong></p>\n<p>除了上面两种方法以外，我们还可以直接在wait对象上部署deferred接口。</p>\n<blockquote>\n<p>　　var dtd = $.Deferred(); // 生成Deferred对象</p>\n<p>　　var wait = function(dtd)</p>\n<p>　　　　var tasks = function()</p>\n<p>　　　　　　alert(&#8220;执行完毕！&#8221;);</p>\n<p>　　　　　　dtd.resolve(); // 改变Deferred对象的执行状态</p>\n<p>　　　　;</p>\n<p>　　　　setTimeout(tasks,5000);</p>\n<p>　　};</p>\n<p>　　<strong>dtd.promise(wait);</strong></p>\n<p>　　wait.done(function() alert(&#8220;哈哈，成功了！&#8221;); )</p>\n<p>　　.fail(function() alert(&#8220;出错啦！&#8221;); );</p>\n<p>　　wait(dtd);</p>\n<p>（运行<a rel=\"nofollow\" href=\"http://jsfiddle.net/ruanyf/PF7Xf/\">代码示例7</a>）</p>\n</blockquote>\n<p>这里的关键是dtd.promise(wait)这一行，它的作用就是在wait对象上部署Deferred接口。正是因为有了这一行，后面才能直接在wait上面调用done()和fail()。</p>\n<p><strong>八、小结：deferred对象的方法</strong></p>\n<p>前面已经讲到了deferred对象的多种方法，下面做一个总结：</p>\n<p>　　（1） <a rel=\"nofollow\" href=\"http://api.jquery.com/category/deferred-object/\">$.Deferred()</a> 生成一个deferred对象。</p>\n<p>　　（2） <a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.done/\">deferred.done()</a> 指定操作成功时的回调函数</p>\n<p>　　（3） <a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.fail/\">deferred.fail()</a> 指定操作失败时的回调函数</p>\n<p>　　（4） <a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.promise/\">deferred.promise()</a> 没有参数时，作用为保持deferred对象的运行状态不变；接受参数时，作用为在参数对象上部署deferred接口。</p>\n<p>　　（5） <a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.resolve/\">deferred.resolve()</a> 手动改变deferred对象的运行状态为&#8221;已完成&#8221;，从而立即触发done()方法。</p>\n<p>　　（6） <a rel=\"nofollow\" href=\"http://api.jquery.com/jQuery.when/\">$.when()</a> 为多个操作指定回调函数。</p>\n<p>除了这些方法以外，deferred对象还有三个重要方法，上面的教程中没有涉及到。</p>\n<p>　　（7）<a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.then/\">deferred.then()</a></p>\n<p>有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。</p>\n<blockquote>\n<p>　　$.when($.ajax( &#8220;/main.php&#8221; ))</p>\n<p>　　<strong>.then(successFunc, failureFunc );</strong></p>\n</blockquote>\n<p>如果then()有两个参数，那么第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()。</p>\n<p>　　（8）<a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.reject/\">deferred.reject()</a></p>\n<p>这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为&#8221;已失败&#8221;，从而立即触发fail()方法。</p>\n<p>　　（9）<a rel=\"nofollow\" href=\"http://api.jquery.com/deferred.always/\">deferred.always()</a></p>\n<p>这个方法也是用来指定回调函数的，它的作用是，不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。</p>\n<blockquote>\n<p>　　$.ajax( &#8220;test.html&#8221; )</p>\n<p>　　.always( function()  alert(&#8220;已执行！&#8221;); );</p>\n</blockquote>\n<p>（完）\n</p>\n<div>\n<h3>文档信息</h3>\n<ul>\n<li>版权声明：自由转载-非商用-非衍生-保持署名 | <a rel=\"nofollow\" href=\"http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\">Creative Commons BY-NC-ND 3.0</a></li>\n<li>原文网址：<a rel=\"nofollow\" href=\"http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html\">http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html</a></li>\n<li>最后修改时间：2011年8月16日 23:26</li>\n<li>付费支持（<a rel=\"nofollow\" href=\"http://www.ruanyifeng.com/blog/2011/05/my_google_adsense_is_disabled.html\">说明</a>）：<a rel=\"nofollow\" href=\"https://lab.alipay.com/p.htm?id=2011081500435188\"><img alt=\"支付宝担保交易\" src=\"http://chinadigitaltimes.net/chinese/files/2011/08/3a976ef2rmb_32.png.png\" /></a> | <a rel=\"nofollow\" href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&#038;business=yifeng.ruan@gmail.com&#038;currency_code=USD&#038;amount=0.3&#038;return=http://www.ruanyifeng.com/thank.html&#038;item_name=Ruan%20YiFeng's%20Blog&#038;undefined_quantity=1&#038;no_note=0\"><img alt=\"paypal\" src=\"http://chinadigitaltimes.net/chinese/files/2011/08/5ca83e43dollar_32.png.png\" /></a> </li>\n</ul>\n</div>\n<p><img src=\"http://chinadigitaltimes.net/chinese/files/2011/08/a04f0c26g2011081601.jpg-150x150.jpg\" /></p>\n<p><small>本文由自动聚合程序取自网络，内容和观点不代表数字时代立场</small></p>\n<form method=\"POST\" action=\"http://www.feedblitz.com/f/f.fbz?AddNewUserDirect\">\n定期获得翻墙信息？<a href=\"http://www.feedblitz.com/f/?Sub=738338\">请电邮订阅数字时代</a> <br /><input name=\"EMAIL\" maxlength=\"64\" type=\"text\" size=\"25\" value=\"\"><br />\n<input name=\"FEEDID\" type=\"hidden\" value=\"738338\"><br />\n<input name=\"PUBLISHER\" type=\"hidden\" value=\"7485568\"><br />\n<input type=\"submit\" value=\"订阅!\"><br />\n</form>\n","author":991,"categories":[9203],"tags":[9400]}