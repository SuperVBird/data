{"id":208923,"link":"https://chinadigitaltimes.net/chinese/2012/02/编程随想-为啥俺推荐python4：作为函数式编程语言的python/","date":"2012-02-07T17:13:51Z","modified":"2012-02-07T17:13:51Z","title":"编程随想 | 为啥俺推荐Python[4]：作为函数式编程语言的Python","content":"<p>春节前有<a rel=\"nofollow\" href=\"http://program-think.blogspot.com/2010/08/why-choose-python-3-oop.html#c4890538441391342385\">网友留言</a>，提醒Python系列好久没更新了（不知不觉又过了一年多）。俺回复留言说：春节假期补上后一篇。昨天听到鞭炮声才发觉元宵已经到了，赶忙写出本文。<br />　　<a rel=\"nofollow\" href=\"http://program-think.blogspot.com/2010/08/why-choose-python-3-oop.html\">前一个帖子</a>介绍了Python作为&#8221;面向对象编程&#8221;（以下简称OOP）语言的特点，今天来聊一聊Python作为&#8221;函数式编程&#8221;（以下简称FP）语言的特点。考虑到本系列面向的是Python的门外汉或刚入门的新手，故本文仅介绍若干浅显的FP特性。</p>\n<h2>★什么是函数式编程</h2>\n<p>　　说实话，&#8221;函数式编程语言&#8221;是一个很大的话题。由于篇幅有限，本文不可能对这个话题做全面介绍。俺干脆偷一下懒，只简单说说。<br />　　从字面上看，所谓的函数式编程，就是以&#8221;函数&#8221;为中心的&#8221;编程范式&#8221;。估计有同学又会问了，啥是&#8221;编程范式&#8221;捏？哎呦，这又是一个很大的话题。通俗来讲，&#8221;编程范式&#8221;就是指编程的套路。比方说大家很熟悉的OOP，就是一种&#8221;编程范式&#8221;。FP跟OOP一样，都是一种编程的套路。做个简单类比：OOP以&#8221;对象/类&#8221;作为程序设计的核心，而FP以&#8221;函数&#8221;作为程序设计的核心。</p>\n<h2>★FP的特点</h2>\n<p>　　既然说到FP，自然要稍微说一下FP的特色。</p>\n<h3>◇函数很牛X</h3>\n<p>　　刚才说了，FP是以函数为中心。既然如此，在支持FP的语言中，函数的功能自然十分牛X。通俗地说，OOP语言中，类/对象能干的事情，FP语言中的函数也能干。下面做一些对比，以加深大伙儿的印象。<br />OOP中，对象可以互相赋值；FP中，函数可以互相赋值。<br />OOP中，对象可以作为函数的参数/返回值，FP中，函数可以作为函数的参数/返回值。<br />某些OOP中，类可以嵌套定义；FP中，函数可以嵌套定义。<br />某些OOP中，可以有匿名类；FP中，可以有匿名函数。</p>\n<h3>◇避免副作用</h3>\n<p>　　在FP中，特别强调函数不要有&#8221;副作用&#8221;（洋文叫&#8221;<a rel=\"nofollow\" href=\"http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29\">side effect&#8221;</a>）。没有副作用的函数，又称之为纯函数（pure function）。其输出完全依赖于输入。换句话说，只要输入一样，输出就一样。<br />　　要成为纯函数，函数内部不能读写函数外部变量、不能有设备I/O（比如读写文件）&#8230;&#8230;<br />　　无副作用是FP的重要特性。FP的很多优点来自于此特性。</p>\n<h3>◇避免控制流</h3>\n<p>　　在FP中，尽量避免用控制流语句（循环语句、判断语句）。对于控制流语句，FP有另外的替代方式。比如：常用递归或高阶函数来替代循环。如此一来，FP的代码会显得更简洁，更可读。</p>\n<h3>◇多态</h3>\n<p>　　大部分支持FP的语言，也都支持多态。函数参数支持多态化，便可实现非常灵活的功能。</p>\n<p>　　说了这么多，不知道大伙儿明白了没？还是没整明白的同学，请看<a rel=\"nofollow\" href=\"http://en.wikipedia.org/wiki/Functional_programming\">维基百科的英文词条</a>（中文词条太简单，看不明白滴）。<br />　　洋文实在看不下去吗？那不妨看看IT大牛Joel写的《<a rel=\"nofollow\" href=\"http://www.joelonsoftware.com/items/2006/08/01.html\">你的编程语言能这样做吗？</a>》（中文版在&#8221;<a rel=\"nofollow\" href=\"http://local.joelonsoftware.com/wiki/%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80%E5%8F%AF%E4%BB%A5%E9%80%99%E6%A8%A3%E5%81%9A%E5%97%8E%EF%BC%9F\">这里</a>&#8220;）。此文以JavaScript来阐述FP的妙处。</p>\n<h2>★FP的优点</h2>\n<p>　　再稍微说一下FP的好处，以强化大伙儿学习的动力。</p>\n<h3>◇模块化</h3>\n<p>　　在FP的思想中，函数最好是&#8221;纯&#8221;的，而且最好只完成&#8221;单一&#8221;的任务。在这种指导思想下，函数的模块化程度自然就高。</p>\n<h3>◇可复用性</h3>\n<p>　　模块化程度高，直接的好处就是可复用性好。</p>\n<h3>◇可读性</h3>\n<p>　　刚才说了，FP的思想强调函数又纯又小。这样的函数，代码的可读性自然好，修改起来也方便。</p>\n<h3>◇易于调试</h3>\n<p>　　前面提到了纯函数。如果你的程序中大部分函数都是纯函数，则调试Bug会容易很多。像OOP中，类的多个成员函数都可以修改类的成员变量，有时候会导致调试极其困难。而纯函数没有此问题。<br />　　另外，多线程是调试的一大噩梦。当年俺还专门写过帖子，介绍C++多线程的注意事项（在&#8221;<a rel=\"nofollow\" href=\"http://program-think.blogspot.com/2009/04/debug-test-multithreaded-applications.html\">这里</a>&#8220;）。而纯函数由于没有副作用，不必担心各种&#8221;互斥&#8221;、&#8221;死锁&#8221;等问题。</p>\n<h3>◇易于测试</h3>\n<p>　　除了易于调试，纯函数的输出仅仅依赖于输入，这一特点注定了它很容易进行单元测试。</p>\n<h3>◇适合并行</h3>\n<p>　　在FP中，由于纯函数无副作用，很适合编写并行处理的代码。最典型并且在工业界获得巨大成功的例子就是Erlang。</p>\n<h3>◇其它</h3>\n<p>　　当然啦，FP的好处远不止上述这些（比如还有：利于形式化证明）。限于篇幅，俺就不展开了。</p>\n<h2>★Python的函数语法</h2>\n<p>　　Python中，常见的函数定义和函数调用，想必各位都晓得了。下面说几种不太常见的，且跟FP有关的语法。</p>\n<h3>◇函数赋值</h3>\n<p>　　Python可以把函数直接赋值给一个变量。举例如下：</p>\n<pre><br>def square(n) :  # 这是一个计算平方的小函数，后面会反复用它举例<br>  return n ** 2<br><br>f = square  # 此处赋值给变量f<br>f(10)  # 此处返回100。注意：对该变量使用小括号，等同于调用函数<br></pre>\n<p></p>\n<h3>◇匿名定义</h3>\n<p>　　Python可以用lambda关键字定义<b>单行</b>的匿名函数。套用刚才的例子</p>\n<p>square = lambda x : x**2  # 定义一个单参数的匿名函数，并把该函数赋值给变量<br />square(10)  # 此处返回 100</p>\n<h3>◇嵌套定义</h3>\n<p> 　　Python支持函数的嵌套定义（请看如下例子）。这种语法，在&#8221;闭包&#8221;中经常出现（后面会具体介绍闭包）。</p>\n<pre><br>def outer() :  # 外层函数<br>  s = \"hello\"<br>  def inner() :  # 内层函数<br>    print(s)  # 此处引用的是外层作用域的变量<br><br>  inner()  # 输出 hello<br>  n = \"world\"<br>  inner()  # 输出 world<br></pre>\n<p></p>\n<h2>★和FP相关的内置函数</h2>\n<p>　　在接下去聊之前，有必要先介绍几个FP相关的内置函数。</p>\n<h3>◇map(func, iter)</h3>\n<p>为了省事，俺只介绍2参数的map（正宗的map支持N参数）。<br />参数func是个函数，参数iter是个迭代器（也可以理解为集合）<br />map()会把iter的每个元素传给func，并把每次调用的结果保存到一个list中，然后返回此list。<br />举例：<br />挨个计算整数list的平方</p>\n<p>map(square, [1, 2, 3])  # 返回 [1, 4, 9]</p>\n<p></p>\n<h3>◇filter(func, iter)</h3>\n<p>参数含义同map<br />filter()会把iter的每个元素传给func，如果func返回结果为True，就把元素保存在一个list中，最后返回此list。<br />举例：<br />要过滤出所有奇数</p>\n<pre><br>def odd(n) :<br>  return (n%2) == 1<br><br>filter(odd, [1, 2, 3])  # 返回[1, 3]<br></pre>\n<p>此处可以用上lambda，把代码简化为一行</p>\n<p>filter(lambda n: (n%2)==1, lst)</p>\n<p></p>\n<h2>★消除控制流</h2>\n<p>　　为了让大伙儿更深刻体会FP风格同传统风格的差别，俺把刚才两个例子组合一下——要求返回整数list中所有奇数的平方。<br />传统的写法（有控制流）</p>\n<pre><br>def func1(lst) :<br>  new_lst = []<br>  for n in lst :<br>    if odd(n) :<br>      new_lst.append(square(n))<br>  return new_lst<br></pre>\n<p>FP的写法（无控制流）</p>\n<pre><br>def func2(lst) :<br>  return map(square, filter(odd, lst))<br></pre>\n<p>怎么样？是不是更简洁？连 for / if 两个关键字都不需要。</p>\n<h2>★List Comprehension</h2>\n<p>　　这个洋文比较难翻译。有人叫做&#8221;列表推导&#8221;，也有人称为&#8221;列表展开&#8221;或&#8221;列表解析&#8221;。（俺比较喜欢头一个翻译——不禁让人联想到&#8221;推倒&#8221;:）<br />　　在Python中，这是一个很好吃的语法糖——可以让你写出很简洁、很优雅的代码。<br />举例1：<br />还拿刚才过滤奇数的例子。</p>\n<p>filter(lambda n: (n%2)==1, lst)</p>\n<p>上述写法可以等价替换为列表推导</p>\n<p>[n for n in lst if (n%2)==1]</p>\n<p>举例2：<br />再来一个稍微复杂的例子。假设有两个整数list，分别存储矩形的宽度和高度。现在想把所有的宽度和高度进行两两组合，把大于10的面积打印出来。<br />传统的写法（2层循环，4行代码）</p>\n<pre><br>for w in width :<br>  for h in height :<br>    if w*h > 10 :<br>      print(w*h)<br></pre>\n<p>FP的写法（无循环，1行代码，多精致啊）</p>\n<p>print( [w*h for w in width for h in height if w*h > 10] )</p>\n<p>　　除了列表推导，Python中还有字典推导、集合推导等等。为了省点口水，暂且打住。</p>\n<h2>★闭包</h2>\n<p>　　闭包，洋文叫&#8221;closure&#8221;，解释在&#8221;<a rel=\"nofollow\" href=\"http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29\">这里</a>&#8220;。它是FP的常见手法。那闭包到底有啥用捏？俺举一个微积分中，函数求导的例子。（不懂微积分或者对高数有心理阴影的同学，别担心，请把注意力集中在代码上）</p>\n<pre><br>def d(f) :<br>  def calc(x) :<br>    dx = 0.000001  # 表示无穷小的Δx<br>    return (f(x+dx) - f(x)) / dx  # 计算斜率。注意，此处引用了外层作用域的变量 f<br>  return calc  # 此处用函数作为返回值（也就是函数 f 的导数）<br></pre>\n<p>现在，假设要计算二次函数 f(x) = x<sup>2</sup> + x + 1 的导数，只需</p>\n<p>f = lambda x : x**2 + x + 1  # 先把二次函数用代码表达出来<br />f1 = d(f)  # 这个f1 就是 f 的一阶导数啦。注意，导数依然是个函数</p>\n<p>有了一阶导数，就可以很容易地计算该函数在某点的斜率<br />比如要计算 x=3 的斜率，只需</p>\n<p>f1(3)</p>\n<p>如果要想得到二阶导数（导数的导数），只需依样画葫芦（瞧这代码写得多优雅）</p>\n<p>f2 = d(f1)</p>\n<p>　　看到这里，大伙儿不妨设想一下：如果不用FP，改用OOP，上述需求该如何实现？俺觉得吧，用OOP来求导，这代码写起来多半是又丑又臭。</p>\n<h2>★结尾</h2>\n<p>　　今天聊了不少FP的语法特性，可惜还是没聊完。由于俺比较懒，而且怕写得太长没人看，所以一些高级话题（比如：迭代器、生成器、等），今天就不介绍了。假如列位看官对那些玩意儿感兴趣，再抽空单独写一帖。</p>\n<p><a rel=\"nofollow\" href=\"http://program-think.blogspot.com/2009/08/why-choose-python-0-overview.html#index\">回到本系列的目录</a></p>\n<div>\n<hr>\n<h4>版权声明</h4>\n<p>本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者&#8221;<b>编程随想</b>&#8220;和本文原始地址。</p>\n<h4>学习翻墙</h4>\n<p>发信给<b>help_gfw@yahoo.com</b>可获取翻墙教程 (用国外邮箱以免被墙)<br />如有其它问题, 用<b>program.think@gmail.com</b>联系俺<img width=\"1\" height=\"1\" src=\"https://blogger.googleusercontent.com/tracker/5235590154125226279-1817933058426237822?l=program-think.blogspot.com\" alt=\"\" /></div>\n<div>\n<a rel=\"nofollow\" href=\"http://feeds.feedburner.com/~ff/programthink?a=vJFCskZvQ2Q:YrlYb736CPc:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/programthink?d=yIl2AUoC8zA\" border=\"0\" /></a> <a rel=\"nofollow\" href=\"http://feeds.feedburner.com/~ff/programthink?a=vJFCskZvQ2Q:YrlYb736CPc:qj6IDK7rITs\"><img src=\"http://feeds.feedburner.com/~ff/programthink?d=qj6IDK7rITs\" border=\"0\" /></a> <a rel=\"nofollow\" href=\"http://feeds.feedburner.com/~ff/programthink?a=vJFCskZvQ2Q:YrlYb736CPc:7Q72WNTAKBA\"><img src=\"http://feeds.feedburner.com/~ff/programthink?d=7Q72WNTAKBA\" border=\"0\" /></a> <a rel=\"nofollow\" href=\"http://feeds.feedburner.com/~ff/programthink?a=vJFCskZvQ2Q:YrlYb736CPc:V_sGLiPBpWU\"><img src=\"http://feeds.feedburner.com/~ff/programthink?i=vJFCskZvQ2Q:YrlYb736CPc:V_sGLiPBpWU\" border=\"0\" /></a>\n</div>\n<p><img src=\"http://feeds.feedburner.com/~r/programthink/~4/vJFCskZvQ2Q\" height=\"1\" width=\"1\" /></p>\n<p><small>本文由自动聚合程序取自网络，内容和观点不代表数字时代立场</small></p>\n<p><iframe src=\"https://docs.google.com/spreadsheet/embeddedform?formkey=dGRpN3FrVThuMFFsZHBZcmNGLW94dEE6MQ\" width=\"450\" height=\"309\" frameborder=\"0\" marginheight=\"0\" marginwidth=\"0\">Loading&#8230;</iframe></p>\n<form method=\"POST\" action=\"http://www.feedblitz.com/f/f.fbz?AddNewUserDirect\">\n定期获得翻墙信息？<a href=\"http://www.feedblitz.com/f/?Sub=750556\">请电邮订阅数字时代</a> <br /><input name=\"EMAIL\" maxlength=\"64\" type=\"text\" size=\"25\" value=\"\"><br />\n<input name=\"FEEDID\" type=\"hidden\" value=\"750556\"><br />\n<input name=\"PUBLISHER\" type=\"hidden\" value=\"7485568\"><br />\n<input type=\"submit\" value=\"订阅!\"><br />\n</form>\n","author":999,"categories":[9203],"tags":[9400,18635,10360]}