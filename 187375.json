{"id":187375,"link":"https://chinadigitaltimes.net/chinese/2011/10/阮一峰-javascript文件加载：labjs和requirejs/","date":"2011-10-10T10:32:04Z","modified":"2011-10-10T10:32:04Z","title":"阮一峰 | Javascript文件加载：LABjs和RequireJS","content":"<p><p>传统上，加载Javascript文件都是使用<script>标签。</p>\n<p>就像下面这样：</p>\n<blockquote>\n<p>　　<script type=\"text/javascript\" src=\"example.js\"></script></p>\n</blockquote>\n<p><img src=\"http://image.beekka.com/blog/201110/bg2011100301.png\" /></p>\n<p><script>标签很方便，只要加入网页，浏览器就会读取并运行。但是，它存在一些严重的缺陷。</p>\n<p>　　<strong>（1）严格的读取顺序。</strong>由于浏览器按照<script>在网页中出现的顺序，读取Javascript文件，然后立即运行，导致在多个文件互相依赖的情况下，依赖性最小的文件必须放在最前面，依赖性最大的文件必须放在最后面，否则代码会报错。</p>\n<p>　　<strong>（2）性能问题。</strong>浏览器采用\"同步模式\"加载<script>标签，也就是说，页面会\"堵塞\"（blocking），等待javascript文件加载完成，然后再运行后面的HTML代码。当存在多个<script>标签时，浏览器无法同时读取，必须读取完一个再去读取另一个，造成读取时间大大延长，页面响应缓慢。</p>\n<p>为了解决这些问题，可以使用DOM方法，动态加载Javascript文件。</p>\n<blockquote>\n<p>　　function loadScript(url)</p>\n<p>　　　　var script = document.createElement(\"script\");</p>\n<p>　　　　script.type = \"text/javascript\";</p>\n<p>　　　　script.src = url;</p>\n<p>　　　　document.body.appendChild(script);</p>\n<p>　　</p>\n</blockquote>\n<p>这样做的原理是，浏览器即时创造出一个<script>标签，然后\"异步\"读取Javascript文件。这样不会造成页面堵塞，但会造成另外一个问题：这样加载的Javascript文件，不在原始的DOM结构之中，因此在DOM-ready（DOMContentLoaded）事件和window.onload事件中指定的回调函数对它无效。</p>\n<p>外部函数库<a rel=\"nofollow\" href=\"http://labjs.com/\">LABjs</a>和<a rel=\"nofollow\" href=\"http://requirejs.org/\">RequireJS</a>，可以帮助我们更有效地管理Javascript加载。 </p>\n<p>下面根据<a rel=\"nofollow\" href=\"http://msdn.microsoft.com/en-us/scriptjunkie/ff943568\">ScriptJunkie</a>的文章，举一个最简单的例子，来说明这两个函数库的基本用法。更高级的用法，请参阅它们的文档。</p>\n<blockquote>\n<p>　　<script src=\"script1.js\"></script></p>\n<p>　　<script src=\"script2-a.js\"></script></p>\n<p>　　<script src=\"script2-b.js\"></script></p>\n<p>　　<script type=\"text/javascript\"></p>\n<p>　　　　initScript1();</p>\n<p>　　　　initScript2();</p>\n<p>　　</script></p>\n<p>　　<script src=\"script3.js\"></script></p>\n<p>　　<script type=\"text/javascript\"></p>\n<p>　　　　initScript3();</p>\n<p>　　</script></p>\n</blockquote>\n<p>上面这段代码，将依次加载4个javascript文件：script1.js、script2-a.js、script2-b.js和script3.js。在加载完前三个文件后，运行两个函数initScript1()和initScript2()；加载完第四个文件后，再运行函数initScript3()。</p>\n<p>下面，用LABjs对其进行改写：</p>\n<blockquote>\n<p>　　<script src=\"LAB.js\"></script></p>\n<p>　　<script type=\"text/javascript\"></p>\n<p>　　　　$LAB</p>\n<p>　　　　　.script(\"script1.js\").wait()</p>\n<p>　　　　　.script(\"script2-a.js\")</p>\n<p>　　　　　.script(\"script2-b.js\")</p>\n<p>　　　　　.wait(function()</p>\n<p>　　　　　　　initScript1();</p>\n<p>　　　　　　　initScript2();</p>\n<p>　　　　　)</p>\n<p>　　　　　.script(\"script3.js\")</p>\n<p>　　　　　.wait(function()</p>\n<p>　　　　　　　initScript3();</p>\n<p>　　　　　);</p>\n<p>　　</script></p>\n</blockquote>\n<p>首先，$LAB对象替代了<script>标签，然后.script()方法表示加载Javascript文件，不带参数的.wait()方法表示立即运行刚才加载的Javascript文件，带参数的.wait()方法也是立即运行刚才加载的Javascript文件，但是还运行参数中指定的函数。</p>\n<p>这里需要注意的是，可以同时运行多条$LAB链，但是它们之间是完全独立的，不存在次序关系。如果你要确保一个Javascript文件在另一个文件之后运行，你只能把它们写在同一个链操作之中。只有当某些脚本是完全无关的时候，你才应该考虑把它们分成不同的$LAB链，表示它们之间不存在相关关系。</p>\n<p>接下来是requireJS的改写：</p>\n<blockquote>\n<p>　　<script src=\"require.js\"></script></p>\n<p>　　<script type=\"text/javascript\"></p>\n<p>　　　　require([</p>\n<p>　　　　　　\"script1.js\",<br />\n　　　　　　\"script2-a.js\",<br />\n　　　　　　\"script2-b.js\",<br />\n　　　　　　\"script3.js\"</p>\n<p>　　　　　],</p>\n<p>　　　　　function()</p>\n<p>　　　　　　initScript1();<br />\n　　　　　　initScript2();<br />\n　　　　　　initScript3();</p>\n<p>　　　　　</p>\n<p>　　　　);</p>\n<p>　　</script></p>\n</blockquote>\n<p>require()接受两个参数，第一个数组表示所要加载的Javascript文件，第二个是加载完成后所要运行的回调函数。原生的require()不支持按次序加载，所以四个Javascript文件到底先加载哪个，无法事前知道，require()只保证这四个文件全部加载完成之后，才会运行所指定的回调函数。</p>\n<p>如果按次序加载对你很重要，你可以使用官方提供的<a rel=\"nofollow\" href=\"http://requirejs.org/docs/api.html#order\">order插件</a>。</p>\n<p>（完）\n</p>\n<div>\n<h3>文档信息</h3>\n<ul>\n<li>版权声明：自由转载-非商用-非衍生-保持署名 | <a rel=\"nofollow\" href=\"http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\">Creative Commons BY-NC-ND 3.0</a></li>\n<li>原文网址：<a rel=\"nofollow\" href=\"http://www.ruanyifeng.com/blog/2011/10/javascript_loading.html\">http://www.ruanyifeng.com/blog/2011/10/javascript_loading.html</a></li>\n<li>最后修改时间：2011年10月 3日 12:18</li>\n<li>付费支持（<a rel=\"nofollow\" href=\"http://www.ruanyifeng.com/blog/2011/05/my_google_adsense_is_disabled.html\">说明</a>）：<a rel=\"nofollow\" href=\"https://lab.alipay.com/p.htm?id=2011081500435188\"><img alt=\"支付宝担保交易\" src=\"http://chinadigitaltimes.net/chinese/files/2011/10/3a976ef2rmb_32.png.png\" /></a> | <a rel=\"nofollow\" href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_xclick&#038;business=yifeng.ruan@gmail.com&#038;currency_code=USD&#038;amount=0.3&#038;return=http://www.ruanyifeng.com/thank.html&#038;item_name=Ruan%20YiFeng's%20Blog&#038;undefined_quantity=1&#038;no_note=0\"><img alt=\"paypal\" src=\"http://chinadigitaltimes.net/chinese/files/2011/10/5ca83e43dollar_32.png.png\" /></a> </li>\n</ul>\n</div>\n<div>\n</div>\n<p><img src=\"http://chinadigitaltimes.net/chinese/files/2011/10/c3e10048g2011100301.png-150x134.png\" /></p>\n<p><small>本文由自动聚合程序取自网络，内容和观点不代表数字时代立场</small></p>\n<form method=\"POST\" action=\"http://www.feedblitz.com/f/f.fbz?AddNewUserDirect\">\n定期获得翻墙信息？<a href=\"http://www.feedblitz.com/f/?Sub=738338\">请电邮订阅数字时代</a> <br /><input name=\"EMAIL\" maxlength=\"64\" type=\"text\" size=\"25\" value=\"\"><br />\n<input name=\"FEEDID\" type=\"hidden\" value=\"738338\"><br />\n<input name=\"PUBLISHER\" type=\"hidden\" value=\"7485568\"><br />\n<input type=\"submit\" value=\"订阅!\"><br />\n</form>\n","author":991,"categories":[9203],"tags":[9400]}