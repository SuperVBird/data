{"id":236394,"link":"https://chinadigitaltimes.net/chinese/2012/07/翻墙-用python写的socks5代理及其分支/","date":"2012-07-02T00:00:17Z","modified":"2012-07-02T00:00:17Z","title":"翻墙 | 用Python写的socks5代理及其分支","content":"<p>原文：<a rel=\"nofollow\" target=\"_blank\" href=\"http://igfw.net/archives/10294\">http://igfw.net/archives/10294</a></p>\n<div></div>\n<div>\n<p><a rel=\"nofollow\" target=\"_blank\" href=\"http://xiaoxia.org/\">小虾</a>是个好同学，以前介绍过其用Python写的VPN程序<a rel=\"nofollow\" target=\"_blank\" href=\"http://igfw.net/archives/7756\">udpip</a>，据说<a rel=\"nofollow\" target=\"_blank\" href=\"http://igfw.net/archives/10144\">WCProxy</a>最初也是其用Python写成的，这次要介绍的是其用Python写的socks5代理及其分支。</p>\n<p>好吧上<strong>Python写的socks5服务器端</strong>代码（<a rel=\"nofollow\" target=\"_blank\" href=\"http://xiaoxia.org/2011/03/29/written-by-python-socks5-server/\">来源</a>）：</p>\n<pre>import socket, sys, select, SocketServer, struct, time          class ThreadingTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer): pass        class Socks5Server(SocketServer.StreamRequestHandler):            def handle_tcp(self, sock, remote):                fdset = [sock, remote]                while True:                    r, w, e = select.select(fdset, [], [])                    if sock in r:                        if remote.send(sock.recv(4096)) <= 0: break                    if remote in r:                        if sock.send(remote.recv(4096)) <= 0: break            def handle(self):                try:                    print &#39;socks connection from &#39;, self.client_address                    sock = self.connection                    # 1. Version                    sock.recv(262)                    sock.send(b\"x05x00\");                    # 2. Request                    data = self.rfile.read(4)                    mode = ord(data[1])                    addrtype = ord(data[3])                    if addrtype == 1:       # IPv4                        addr = socket.inet_ntoa(self.rfile.read(4))                    elif addrtype == 3:     # Domain name                        addr = self.rfile.read(ord(sock.recv(1)[0]))                    port = struct.unpack(&#39;>H&#39;, self.rfile.read(2))                    reply = b\"x05x00x00x01\"                    try:                        if mode == 1:  # 1. Tcp connect                            remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                            remote.connect((addr, port[0]))                            print &#39;Tcp connect to&#39;, addr, port[0]                        else:                            reply = b\"x05x07x00x01\" # Command not supported                        local = remote.getsockname()                        reply += socket.inet_aton(local[0]) + struct.pack(\">H\", local[1])                    except socket.error:                        # Connection refused                        reply = &#39;x05x05x00x01x00x00x00x00x00x00&#39;                    sock.send(reply)                    # 3. Transfering                    if reply[1] == &#39;x00&#39;:  # Success                        if mode == 1:    # 1. Tcp connect                            self.handle_tcp(sock, remote)                except socket.error:                    print &#39;socket error&#39;        def main():            server = ThreadingTCPServer((&#39;&#39;, 1080), Socks5Server)            server.serve_forever()        if __name__ == &#39;__main__&#39;:            main()</pre>\n<p>直接运行这个程序就给本机建立了一个socks5的代理服务器（需要Python2.6以上版本才能运行）。</p>\n<p>  就这么简单，无论你看懂没看懂，反正我是不懂Python代码。</p>\n<p>好吧那发一个某人自用了一年多的翻墙工具 shadowsocks 吧，这个shadowsocks就是根据上面的代码修改的，这个用 Python 写的 socks 加密代理，加密方法很简单，不过欺骗 GFW 足够了。 shadowsocks作者说；“当初激发我写这个东西的原因是 ssh tunnel 容易断，每次重连会卡一段时间，并且并发能力有限。于是用普通的 socket server，来一个连接建一个连接。到现在用了一年多，感觉挺稳定，不如发布出来吧。<br />  ”。</p>\n<p><strong>shadowsocks项目地址</strong>：<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/clowwindy/shadowsocks\">https://github.com/clowwindy/shadowsocks</a></p>\n<p>使用方法：</p>\n<p>Put <code>server.py</code> on your server. Edit <code>server.py</code>, change the following values:</p>\n<pre><code>PORT server port   KEY a password to identify clients </code></pre>\n<p>Run <code>python server.py</code> on your server. To run it in the background, run <code>setsid python server.py</code>.</p>\n<p>Put <code>local.py</code> on your client machine. Edit <code>local.py</code>, change these values:</p>\n<pre><code>SERVER your server ip or hostname   REMOTE_PORT server port PORT local port   KEY a password, it must be the same as the password of your server </code></pre>\n<p>Run <code>python local.py</code> on your client machine.</p>\n<p>Change proxy settings of your browser into</p>\n<pre><code>SOCKS5 127.0.0.1:PORT </code></pre>\n<p>我没有测试过这个程序，我测试的是balan-proxy程序。balan-proxy程序fork自shadowsocks。没修改什么，就用生成器循环返回服务器地址，增加对多个服务端的支持，如果在限制带宽的内网使用，可达到多倍带宽的效果。在下载http资源，及播放在线视频时有显著加速功能。</p>\n<p><strong>balan-proxy项目地址</strong>：<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/lerry/balan-proxy\">https://github.com/lerry/balan-proxy</a></p>\n<p>  增加自定义服务器列表支持，请将服务器地址列表放在同文件夹下，文件名： list.txt 格式:<br /><a rel=\"nofollow\" target=\"_blank\" href=\"http://8.8.8.8:8499\">8.8.8.8:8499</a><br /><a rel=\"nofollow\" target=\"_blank\" href=\"http://4.4.4.4:8499\">4.4.4.4:8499</a><br />#<a rel=\"nofollow\" target=\"_blank\" href=\"http://1.1.1.1:8849\">1.1.1.1:8849</a><br />暂时不使用的服务器地址可使用#注释</p>\n<p>用法和shadowsocks一样（ 装gevent，然后在启动server.py，能省下一些内存）。</p>\n<p>  不过上面代理加密简单，如果要高强度的加密可以考虑换成两边用ssl来通信，这就有了sockstunnel，sockstunnel是一个使用ssl加密隧道的简单 socks5服务器（shadowsocks也在测试更强的加密方式）。</p>\n<p><strong>sockstunnel项目地址</strong>：<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/wynemo/sockstunnel\">https://github.com/wynemo/sockstunnel</a></p>\n<p>在服务器上，使用 openssl 生成您的密钥和证书文件的方法</p>\n<pre><code>openssl genrsa -out privkey.pem 2048   openssl req -new -x509 -key privkey.pem -out cacert.pem -days 1095</code></pre>\n<p>作者说其在server:ubuntu 11.10 x64 python2.7 /client:windows7 python 2.7.3,ubuntu 11.10 python 2.7.2下测试成功，有兴趣的可以试试。</p>\n<p>除了加密问题，还有人提出了IPv6支持问题，于是shadowsocks作者加了一个实验性的 IPv6 branch，Server 是 IPv6 地址，因为和 IPv4 不兼容，所以暂时没合并。</p>\n<p>  <strong>IPv6 branch项目地址</strong>：<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/clowwindy/shadowsocks/tree/ipv6\">https://github.com/clowwindy/shadowsocks/tree/ipv6</a></p>\n<p>  shadowsocks作者折腾完Python版后又把目光瞄向了node.js，这就有了加密代理 shadowsocks node.js 版。作者说加密代理 shadowsocks node.js 版经过一个多月的改进现在可以在 1000 并发，500 QPS 下稳定工作。现在用在一个项目中，每天通过上百 GB 流量。</p>\n<p>  <strong>shadowsocks-nodejs项目地址</strong>：<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/clowwindy/shadowsocks-nodejs\">https://github.com/clowwindy/shadowsocks-nodejs</a></p>\n<p>  和原 Python 版相比优势：<br />1. 不会大量创建线程，VSZ 使用很少，适合 OpenVZ。<br />2. 支持更大并发。因为 Python 版用的是 select()，fd > 1024 的时候就挂了。</p>\n<p>缺点：<br />下载大文件时内存占用峰值会达到几十 MB，怀疑与 V8 的 GC 策略有关。(<a rel=\"nofollow\" target=\"_blank\" href=\"http://www.v2ex.com/t/37359\">参考</a>)<br />  当然 Python 版也可以改用非阻塞模型，不过写起来比 nodejs 麻烦就是了。欢迎有兴趣的童鞋做这样的尝试 :)</p>\n<p>说明：<br />如果都升到最新版，Python 版与 node.js 版的协议是互相兼容的。即可以用 python client + node.js server。<br />  另外感叹 V8 的性能确实很好，基本相同的计算密码表过程，纯 js 实现比纯 Python 实现快了几十倍。</p>\n<p>使用方法：</p>\n<p lang=\"zh-chs\">  Edit <code>config.json</code>, change the following values:</p>\n<pre><code>server your server ip or hostname   server_port server port   local_port local port   password a password used to encrypt transfer   timeout in seconds </code></pre>\n<p>Put all the files on your server. Run <code>node server.js</code> on your server. To run it in the background, run <code>setsid node server.js</code>.</p>\n<p>Put all the files on your client machine. Run <code>node local.js</code> on your client machine.</p>\n<p lang=\"zh-chs\">  Change proxy settings of your browser into</p>\n<pre><code>SOCKS5 127.0.0.1:local_port </code></pre>\n<p>  另外作者还将多 server 功能加到一个新分支里了。</p>\n<p><strong>multi-server branc项目地址</strong>：<a rel=\"nofollow\" target=\"_blank\" href=\"https://github.com/clowwindy/shadowsocks-nodejs/tree/multi-server\">https://github.com/clowwindy/shadowsocks-nodejs/tree/multi-server</a></p>\n<p>50多行代码引起了这许多故事，终究使用起来还是要比ssh代理速度快，有VPS的同学可以试试啦。</p>\n<p>  另外以前说过goagent在<a rel=\"nofollow\" target=\"_blank\" href=\"http://repo.or.cz/w/goagent.git/snapshot/13ce2fd7a5ff624fe1cfc9e8108208e30e79e1e9.zip\">1.9.1a2</a>测试版本中加入使用ssl加密独立主机上的wsgi.py（使用方法:python wsgi.py 443 -ssl ），这个和上面介绍的也是殊途同归，不过goagent貌似也开始独立主机上的socks5代理了。</p>\n<p><strong>本文原始地址</strong>：<a rel=\"nofollow\" target=\"_blank\" href=\"http://igfw.net/archives/10294\">http://igfw.net/archives/10294</a></p>\n</p></div>\n<div>请点击<a rel=\"nofollow\" target=\"_blank\" href=\"https://mycdt4.info/chinese/\">https://mycdt4.info/chinese/</a>，穿墙访问《中国数字时代》。《中国数字时代》开通IPv6，欢迎穿墙阅读。翻越防火长城，你可以到达世界上的每一个角落。（Across the Great Firewall, you can reach every corner in the world.）翻墙利器赛风3下载地址：<a rel=\"nofollow\" target=\"_blank\" href=\"http://dld.bz/caonima326\n\n\"> http://dld.bz/caonima326</p>\n<p></a>，<a rel=\"nofollow\" target=\"_blank\" href=\"http://dld.bz/caonima745\">http://dld.bz/caonima745</a><img width=\"1\" height=\"1\" src=\"https://blogger.googleusercontent.com/tracker/5500297126185736776-6553744339627983047?l=www.chinagfw.org\" alt=\"\" /></div>\n</p>\n<p><small>本文由自动聚合程序取自网络，内容和观点不代表数字时代立场</small></p>\n<p><iframe src=\"https://docs.google.com/spreadsheet/embeddedform?hl=zh-CN&#038;formkey=dGRpN3FrVThuMFFsZHBZcmNGLW94dEE6MQ\" width=\"510\" height=\"328\" frameborder=\"0\" marginheight=\"0\" marginwidth=\"0\">Loading&#8230;</iframe></p>\n<form method=\"POST\" action=\"http://chinadigitaltimes.us4.list-manage.com/subscribe/post?u=17daa75df533f6c6ff72e51ab&#038;id=b4fd4ae247\">\n定期获得翻墙信息？<a href=\"http://eepurl.com/mstlf\">请电邮订阅数字时代</a><br />\n <br /><input type=\"email\" value=\"\" name=\"EMAIL\" id=\"mce-EMAIL_in_post\" size=\"25\" style=\"display:block;\" placeholder=\"请输入您的邮件地址\" required><br />\n\t<input type=\"submit\" value=\"点击订阅\" name=\"subscribe\" style=\"height: 20px;\" id=\"in_post_subscribe\"><br />\n</form>\n","author":1005,"categories":[18269,15300],"tags":[7775,8795]}