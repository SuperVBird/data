{"id":86345,"link":"https://chinadigitaltimes.net/chinese/2010/07/检查素数的正则表达式/","date":"2010-07-23T14:36:05Z","modified":"2010-07-23T14:36:05Z","title":"检查素数的正则表达式","content":"<p><p>来自: <a href=\"http://www.feedzshare.com/b/557567/2\">酷壳 &#8211; CoolShell.cn &#8211; FeedzShare</a>  <br />\n<br />发布时间:2010年07月23日,  已有 12 人推荐 </p>\n<hr>\n<div>\n<blockquote><p>Shared by  Lee<br />\n<br />\n比前二天看的讲得详细，后面还有用正则表达式解方程。</p></blockquote>\n<p>一般来说，我们会使用正规表达式来做字符串匹配，今天在网上浏览的时候，看到了有人用正则表达式来检查一个数字是否为素数（质数），让我非常感兴趣，这个正则表达式如入所示：</p>\n<div><img title=\"检查素数的正则表达式\" src=\"http://coolshell.cn/wp-content/uploads/2010/07/regexpr-for-prime-number.jpg\" alt=\"\" height=\"45\" width=\"450\" /></p>\n<p>检查素数的正则表达式/^1?$|^(11+?) +$/ </p>\n</div>\n<p>要使用这个正规则表达式，你需要把自然数转成多个1的字符串，如：2 要写成 “11”， 3 要写成 “111”, 17 要写成“11111111111111111”，这种工作使用一些脚本语言可以轻松的完成。</p>\n<p>一开始我对这个表达式持怀疑态度，但仔细研究了一下这个表达式，发现是非常合理的，下面，让我带你来细细剖析一下是这个表达式的工作原理。</p>\n<p>首先，我们看到这个表达式中有“|”，也就是说这个表达式可以分成两个部分：/^1?$/ 和 /^(11+?)1+$/</p>\n<ul>\n<li><strong>第一部分：/^1?$/</strong>， 这个部分相信不用我多说了，其表示匹配“非空串”以及字串中不只一个“1”的字符串。</li>\n<li><strong>第二部分：/^(11+?)1+$/</strong>，这个部分是整个表达式的关键部分。把否定条件“^”去掉，其可以分成两个部分，<strong>(11+?)</strong> 和<strong>1+$</strong>，前半部很简单了，匹配以“11”开头的并重复0或n个1的字符串，后面的部分意思是把前半部分作为一个字串去匹配还剩下的字符串1次或多次（这句话的意思是——<span>剩余的字串的1的个数要是前面字串1个数的整数倍</span>）。</li>\n</ul>\n<p>通过上面的分析，我们知道，第二部分是最重要的，对于第二部分，举几个例子，</p>\n<p><span></span></p>\n<p><strong>示例一：判断自然数8</strong>。我们可以知道，8转成我们的格式就是“11111111”，对于<strong>(11+?)</strong>，其匹配了“11”，于是还剩下“111111”，而<strong>1+$</strong>正好匹配了剩下的“111111”，因为，“11”这个模式在“111111”出现了三次，符合模式匹配，返回true。取反（^），所以，得到false，于是这个数不是质数。</p>\n<p><strong>示例二：判断自然数11</strong>。转成我们需要的格式是“11111111111”（十一个1），对于<strong>(11+?)</strong>，其匹配了“11”（前两个1），还剩下“111111111”（九个1），而<strong>1+$</strong>无法为“11”匹配那“九个1”，因为“11”这个模式并没有在“九个1”这个串中正好出现N次。于是，我们的正则表达式引擎会尝试下一种方法，先匹配“111”（前三个1），然后把“111”作为模式去匹配剩下的“11111111”（八个1），很明显，那“八个1”并没有匹配“三个1”多次。所以，引擎会继续向下尝试……直至返回false。</p>\n<p>通过示例二，我们可以得到这样的等价数算算法，正则表达式会匹配这若干个1中有没有出现“二个1”的整数倍，“三个1”的整数倍，“四个1”的整数倍……，而，这正好是我们需要的算素数的算法。现在大家明白了吧。</p>\n<p>下面，我们用perl来使用这个正规则表达式不停地输出素数：（关于perl的语法我就不多说了）</p>\n<pre>perl -e&#39;$|++;(1 x$_)!~/^1?$|^(11+?)1+$/&&print\"$_ \"while ++$_&#39;</pre>\n<p>另外，让我们来举一反三，根据上述的这种方法，我们甚至可以用正则表达式来求证某方式是否有解，如：</p>\n<ul>\n<li><strong>二元方程</strong>：17x + 12y = 51   判断其是否有解的正则表达式是：<strong>^</strong><strong>(</strong><strong>.*</strong><strong>)</strong><strong>1{16}</strong><strong>(</strong><strong>.*</strong><strong>)</strong><strong>2{11}$</strong></li>\n<li><strong>三元方程</strong>：11x + 2y + 5z = 115 判断其是否有解的正则表达式是：<strong>^</strong><strong>(</strong><strong>.*</strong><strong>)</strong><strong>1{10}</strong><strong>(</strong><strong>.*</strong><strong>)</strong><strong>2{1}</strong><strong>(</strong><strong>.*</strong><strong>)</strong><strong>3{4}$</strong></li>\n</ul>\n<p>大家不妨自己做做练习，为什么上述的两个正则表达式可以判断方程是否有解。如果无法参透其中的奥妙的话，你可以读读这篇<a href=\"http://blog.stevenlevithan.com/archives/algebra-with-regexes\">英文文章</a>。</p>\n<p>（全文完）</p>\n<p><img src=\"http://coolshell.cn/?ak_action=api_record_view&#038;id=2704&#038;type=feed\" alt=\"\" /></div>\n<p><img src=\"http://img.tongji.linezing.com/1017243/tongji.gif\" /><img src=\"http://img.tongji.linezing.com/997968/tongji.gif\" /></p>\n<p>请看原文：<br />\n<a target=\"_blank\" href=\"http://coolshell.cn/?p=2704\" title=\"检查素数的正则表达式\">检查素数的正则表达式</a></p>\n","author":176,"categories":[1],"tags":[]}